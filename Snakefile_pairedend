import os
import re
import pandas as pd
import itertools as iter
from snakemake.utils import validate, min_version
min_version("5.5.1")

ADAPTERS=config["adapter"]
CODONS=config["alternativestartcodons"]
DIFFEXPRESS=config["differentialexpression"]
DEEPRIBO=config["deepribo"]

onstart:
   if not os.path.exists("logs"):
     os.makedirs("logs")

samples = pd.read_csv(config["samples"], dtype=str, sep="\t")
samples.sort_values(by=["method", "condition", "replicate"], key=lambda col: col.str.lower() if col.dtype==str else col, inplace=True)
samples.set_index(["method", "condition", "replicate"], drop=False, inplace=True)
samples.index = samples.index.set_levels([i.astype(str) for i in samples.index.levels])
validate(samples, schema="schemas/samples.schema.yaml")

samples_meta_start = samples.loc[(samples["method"] == "RIBO") | (samples["method"] == "TIS") | (samples["method"] == "RNA") | (samples["method"] == "RNATIS")]
samples_meta_stop = samples.loc[(samples["method"] == "TTS") | (samples["method"] == "RNATTS")]

if DIFFEXPRESS.lower() == "on" and len(samples["condition"].unique()) <= 1:
    sys.exit("Differential Expression requested, but only one condition given.\n\
            Please ensure, that you either provide multiple condtions or turn off differential expression in the config.yaml.")

report: "report/workflow.rst"
conditions=sorted(samples["condition"].unique(), key=lambda s: s.lower())
contrastsTupleList=list((iter.combinations(conditions,2)))
contrasts=[[('-'.join(str(i) for i in x))] for x in contrastsTupleList]
flat_contrasts= [item for sublist in contrasts for item in sublist]

def getContrast(flat_contrasts):
    return [("contrasts/"+((element.replace("[", '')).replace("]", '')).replace("'", '')) for element in flat_contrasts]

def getContrastXtail(flat_contrasts):
    return [("xtail/" + ((element.replace("[", '')).replace("]", '')).replace("'", '') + "_significant.xlsx") for element in flat_contrasts]

def getContrastRiborex(flat_contrasts):
    return [("riborex/" + ((element.replace("[", '')).replace("]", '')).replace("'", '') + "_significant.xlsx") for element in flat_contrasts]

def getContrastDeltaTE(flat_contrasts):
    return [("deltate/" + ((element.replace("[", '')).replace("]", '')).replace("'", '') + "_significant.xlsx") for element in flat_contrasts]



def get_wigfiles(wildcards):
  method=samples["method"]
  condition=samples["condition"]
  replicate=samples["replicate"]
  wilds = zip(method, condition, replicate)

  bigwigs = [["totalmapped", "uniquemapped", "global", "centered", "fiveprime", "threeprime"], ["raw", "mil", "min"], ["forward", "reverse"], list(wilds)]
  bigwigs = list(iter.product(*bigwigs))

  wigfiles = []
  for bw in bigwigs:
      wigfiles.append("%stracks/%s/%s-%s-%s.%s.%s.%s.bw" %(bw[0], bw[1], bw[3][0], bw[3][1], bw[3][2], bw[1], bw[2], bw[0]))

  return wigfiles




#Preprocessing
include: "rules/preprocessing.smk"
#Adaper removal and quality control
include: "rules/trimmingmerged.smk"
#removal of reads mapping to ribosomal rna genes
include: "rules/rrnafiltering.smk"
#mapping
include: "rules/mapping.smk"
#Visualization
include: "rules/visualization.smk"
include: "rules/merge.smk"
#reparation
include: "rules/reparation.smk"
#metagene
include: "rules/metageneprofiling.smk"
include: "rules/auxiliary.smk"
#multiqc
include: "rules/qcauxiliary.smk"
include: "rules/qcmerged.smk"
#report
#include: "rules/report.smk"
#readcounts
include: "rules/readcounting.smk"

if DIFFEXPRESS.lower() == "on":
    include: "rules/diffex_contrast.smk"
    include: "rules/diffex_xtail.smk"
    include: "rules/diffex_riborex.smk"
    include: "rules/diffex_deltate.smk"

if DEEPRIBO.lower() == "on":
    #deepribo
    include: "rules/deepribo.smk"
else:
    include: "rules/conditionals.smk"

if DIFFEXPRESS.lower() == "on" and DEEPRIBO.lower() == "on":
   rule all:
      input:
          expand("metageneprofiling/TIS/raw/{method}-{condition}-{replicate}", zip, method=samples_meta_start["method"], condition=samples_meta_start["condition"], replicate=samples_meta_start["replicate"]),
          expand("metageneprofiling/TIS/norm/{method}-{condition}-{replicate}", zip, method=samples_meta_start["method"], condition=samples_meta_start["condition"], replicate=samples_meta_start["replicate"]),
          expand("metageneprofiling/TTS/raw/{method}-{condition}-{replicate}", zip, method=samples_meta_stop["method"], condition=samples_meta_stop["condition"], replicate=samples_meta_stop["replicate"]),
          expand("metageneprofiling/TTS/norm/{method}-{condition}-{replicate}", zip, method=samples_meta_stop["method"], condition=samples_meta_stop["condition"], replicate=samples_meta_stop["replicate"]),
          get_wigfiles,
          "qc/multi/multiqc_report.html",
          "tracks/potentialStopCodons.gff",
          "tracks/potentialStartCodons.gff",
          "tracks/potentialAlternativeStartCodons.gff",
          "tracks/potentialRibosomeBindingSite.gff",
          "auxiliary/annotation_total.xlsx",
          "auxiliary/annotation_unique.xlsx",
          "auxiliary/total_read_counts.xlsx",
          "auxiliary/unique_read_counts.xlsx",
          "auxiliary/samples.xlsx",
          "auxiliary/predictions_reparation.xlsx",
          "figures/heatmap_SpearmanCorr_readCounts.pdf",
          "auxiliary/predictions_deepribo.xlsx",
          rules.createOverviewTableAll.output,
          unpack(getContrast),
          unpack(getContrastXtail),
          unpack(getContrastRiborex),
          unpack(getContrastDeltaTE)

elif DIFFEXPRESS.lower() == "off" and DEEPRIBO.lower() == "on":
   rule all:
      input:
          expand("metageneprofiling/TIS/raw/{method}-{condition}-{replicate}", zip, method=samples_meta_start["method"], condition=samples_meta_start["condition"], replicate=samples_meta_start["replicate"]),
          expand("metageneprofiling/TIS/norm/{method}-{condition}-{replicate}", zip, method=samples_meta_start["method"], condition=samples_meta_start["condition"], replicate=samples_meta_start["replicate"]),
          expand("metageneprofiling/TTS/raw/{method}-{condition}-{replicate}", zip, method=samples_meta_stop["method"], condition=samples_meta_stop["condition"], replicate=samples_meta_stop["replicate"]),
          expand("metageneprofiling/TTS/norm/{method}-{condition}-{replicate}", zip, method=samples_meta_stop["method"], condition=samples_meta_stop["condition"], replicate=samples_meta_stop["replicate"]),
          get_wigfiles,
          "qc/multi/multiqc_report.html",
          "tracks/potentialStopCodons.gff",
          "tracks/potentialStartCodons.gff",
          "tracks/potentialAlternativeStartCodons.gff",
          "tracks/potentialRibosomeBindingSite.gff",
          "auxiliary/annotation_total.xlsx",
          "auxiliary/annotation_unique.xlsx",
          "auxiliary/total_read_counts.xlsx",
          "auxiliary/unique_read_counts.xlsx",
          "auxiliary/samples.xlsx",
          "auxiliary/predictions_reparation.xlsx",
          "figures/heatmap_SpearmanCorr_readCounts.pdf",
          "auxiliary/predictions_deepribo.xlsx",
          rules.createOverviewTablePredictions.output

elif DIFFEXPRESS.lower() == "on" and DEEPRIBO.lower() == "off":
   rule all:
      input:
          expand("metageneprofiling/TIS/raw/{method}-{condition}-{replicate}", zip, method=samples_meta_start["method"], condition=samples_meta_start["condition"], replicate=samples_meta_start["replicate"]),
          expand("metageneprofiling/TIS/norm/{method}-{condition}-{replicate}", zip, method=samples_meta_start["method"], condition=samples_meta_start["condition"], replicate=samples_meta_start["replicate"]),
          expand("metageneprofiling/TTS/raw/{method}-{condition}-{replicate}", zip, method=samples_meta_stop["method"], condition=samples_meta_stop["condition"], replicate=samples_meta_stop["replicate"]),
          expand("metageneprofiling/TTS/norm/{method}-{condition}-{replicate}", zip, method=samples_meta_stop["method"], condition=samples_meta_stop["condition"], replicate=samples_meta_stop["replicate"]),
          get_wigfiles,
          "qc/multi/multiqc_report.html",
          "tracks/potentialStopCodons.gff",
          "tracks/potentialStartCodons.gff",
          "tracks/potentialAlternativeStartCodons.gff",
          "tracks/potentialRibosomeBindingSite.gff",
          "auxiliary/annotation_total.xlsx",
          "auxiliary/annotation_unique.xlsx",
          "auxiliary/total_read_counts.xlsx",
          "auxiliary/unique_read_counts.xlsx",
          "auxiliary/samples.xlsx",
          "auxiliary/predictions_reparation.xlsx",
          "figures/heatmap_SpearmanCorr_readCounts.pdf",
          rules.createOverviewTableDiffExpr.output,
          unpack(getContrast),
          unpack(getContrastXtail),
          unpack(getContrastRiborex),
          unpack(getContrastDeltaTE)

else:
   rule all:
      input:
          expand("metageneprofiling/TIS/raw/{method}-{condition}-{replicate}", zip, method=samples_meta_start["method"], condition=samples_meta_start["condition"], replicate=samples_meta_start["replicate"]),
          expand("metageneprofiling/TIS/norm/{method}-{condition}-{replicate}", zip, method=samples_meta_start["method"], condition=samples_meta_start["condition"], replicate=samples_meta_start["replicate"]),
          expand("metageneprofiling/TTS/raw/{method}-{condition}-{replicate}", zip, method=samples_meta_stop["method"], condition=samples_meta_stop["condition"], replicate=samples_meta_stop["replicate"]),
          expand("metageneprofiling/TTS/norm/{method}-{condition}-{replicate}", zip, method=samples_meta_stop["method"], condition=samples_meta_stop["condition"], replicate=samples_meta_stop["replicate"]),
          get_wigfiles,
          "qc/multi/multiqc_report.html",
          "tracks/potentialStopCodons.gff",
          "tracks/potentialStartCodons.gff",
          "tracks/potentialAlternativeStartCodons.gff",
          "tracks/potentialRibosomeBindingSite.gff",
          "auxiliary/annotation_total.xlsx",
          "auxiliary/annotation_unique.xlsx",
          "auxiliary/total_read_counts.xlsx",
          "auxiliary/unique_read_counts.xlsx",
          "auxiliary/samples.xlsx",
          "auxiliary/predictions_reparation.xlsx",
          "figures/heatmap_SpearmanCorr_readCounts.pdf",
          rules.createOverviewTableReparation.output


onsuccess:
    print("Done, no error")
