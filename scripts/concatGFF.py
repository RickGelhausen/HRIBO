#!/usr/bin/env python
'''This script takes input files generated by
reparationGFF and merges all replicates into one file, for each condition.
'''

import os, sys
import argparse
import pandas as pd
import csv

def concatGFF(args):
    # create dataframes of all non-empty files
    dataFrames = []
    for file in args.reparation_files:
        if os.stat(file).st_size != 0:
            dataFrames.append(pd.read_csv(file, sep='\t', comment="#", header=None))

    # check if dataframe exist for concatination
    if len(dataFrames) != 0:
        mergedGFF = pd.concat(dataFrames)

        ### Handling output
        # write to file
        if args.output_file != "":
            with open(args.output_file, 'w') as f:
                mergedGFF.to_csv(f, sep="\t", header=False, index=False, quoting=csv.QUOTE_NONE)
        else:
            mergedGFF.to_csv(sys.stdout, sep="\t", header=False, index=False, quoting=csv.QUOTE_NONE)
    else:
      open(args.output_file, 'a').close() 

def main():
    # store commandline args
    parser = argparse.ArgumentParser(description='Concatenates multiple gff3 files.')
    parser.add_argument("reparation_files", nargs="*", metavar="reparation", help="Path to reparation gff files.")
    parser.add_argument("-o", "--output_file", action="store", dest="output_file", default="", help="output folder for concatenated files.")
    args = parser.parse_args()

    concatGFF(args)

if __name__ == '__main__':
    main()
